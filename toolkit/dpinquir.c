/*  DEC/CMS REPLACEMENT HISTORY, Element DPINQUIR.C */
/*  *18    3-MAY-1991 12:06:18 BROGNA "" */
/*  *17    1-APR-1991 18:02:38 BROGNA "Toolkit enhancments" */
/*  *16   18-JAN-1991 04:53:40 BROGNA "MSC 6.0x" */
/*  *15   29-NOV-1990 16:58:24 BROGNA "Version 2.21" */
/*  *14   28-NOV-1990 11:51:01 BROGNA "Dual TimeOut levels" */
/*  *13   16-NOV-1990 15:52:11 BROGNA "bug fix" */
/*  *12   16-NOV-1990 12:09:44 BROGNA "Multi-Printer support" */
/*  *11   16-OCT-1990 16:54:20 BROGNA "Right Version" */
/*  *10   16-OCT-1990 16:33:31 BROGNA "ABORT/Remove Film / ERRORNUMBER Bugs Fixed" */
/*  *9    15-OCT-1990 10:14:10 BROGNA "" */
/*  *8    10-OCT-1990 16:57:46 BROGNA "Version 2.1" */
/*  *7     5-OCT-1990 18:47:14 BROGNA "ErrorNumber change" */
/*  *6     3-OCT-1990 15:13:56 BROGNA "Single data structure" */
/*  *5    12-SEP-1990 11:02:26 BROGNA "ToolKit Upgrade" */
/*  *4     6-APR-1990 14:11:42 BROGNA "release 144" */
/*  *3    23-MAR-1990 15:49:08 BROGNA "" */
/*  *2    15-MAR-1990 11:33:58 BROGNA "new toolkit stuff" */
/*  *1    28-FEB-1990 16:10:36 BROGNA "release update" */
/*  DEC/CMS REPLACEMENT HISTORY, Element DPINQUIR.C */
/* DPinquir.c
 * Copyright (C) 1988, 1989, 1990, 1991  Polaroid Corporation.
 */

#include <string.h>

#define DPINQUIR_C
#include "dpalette.h"
#include "dptkcent.h"

/* Digital Palette error messages generated by this code */
static char *UnknownPort = "Parallel Port is unknown to the system." ;
static char *Disconnected = "Digital Palette is Disconnected or Off." ;
static char *Incommunicado = "Digital Palette is Busy, Disconnected or Off." ;
static char *ErrorNotCleared = "Digital Palette Error.  Error Not Cleared." ;
static char *ErrorNotFound = "Digital Palette Error Unknown." ;
static char *NoErrorsReported = "Digital Palette reports no errors." ;

/* Configuration File error messages generated by this code */
static char *cfgNoEnvironment = "Environment variable DPALETTE not found." ;
static char *cfgFileOpenError = "Error Opening Configuration File." ;
static char *cfgFileReadError = "Error Reading Configuration File." ;
static char *cfgFilmReadError = "Error Opening Downloadable Film File." ;
static char *cfgUnknownError = "Configuration File Error." ;

/* Toolkit error messages generated by this code */
static char *BadImageCompression = "Illegal Image Compression." ;
static char *BadTermMethod = "Illegal Exposure Termination Method." ; 
static char *BadToolkitUsage = "Incorrect Toolkit Usage." ;

/* warning messages generated by this code */
static char *NoBufferSpace = "Digital Palette Buffer is Full." ;
static char *ExposureInBox = "Digital Palette Exposure in progress." ;
static char *ExposureComplete =
   "Digital Palette Exposure Complete. REMOVE FILM!" ;
static char *UnknownError = "Unknown Error." ;

/* prototypes for local functions */
int DP_GetPrinterStatus(DP_DATA *, int) ;
int DP_ConfirmBuffer(DP_DATA *, int, int) ;
int DP_ExposureWarning(DP_DATA *) ;
static int DP_InquireError(DP_DATA *) ;

/*
 * DP_GetPrinterStatus(DPdata, Sflag)
 *       Send exposure parameters to Digital Palette.
 *       Input:   DPdata - Pointer to structure of type DP_DATA.
 *                Sflag  - Flag indicating which Inquiries to make.
 */
int
DP_GetPrinterStatus(DPdata, Sflag)
   DP_DATA   *DPdata ;
   int        Sflag ;
   {
   static int          i ;

   if (i = PrInit(DP_PORT(DPdata)))
      {
      if ((!DP_ERRORCLASS(DPdata)) || (DP_PRINTERERROR(DPdata)))
         DP_ERRORCLASS(DPdata) = i ;
		return(DP_InquireError(DPdata)) ;
		}

   /*
    * Inquire Error.
    */
   if (Sflag & INQ_ERROR)
      {
      if (DP_InquireError(DPdata))
         return(DP_ERRORCLASS(DPdata)) ;
      } /* end inquire error */

   /*
    * Inquire Status.
    */
   if (Sflag & INQ_STATUS)
      {
      /*
       * Send the "Inquire Status" command to the Digital Palette.
       * DPsend() will use the "Send Message" command to get the Digital
       * Palette status message.
       * If a problem is encountered try to use the "Inquire Error"
       * command to find out about it and return back to the caller.
       */
      strcpy(DP_COMMAND(DPdata), "IS") ;
      DP_DATA_BYTES(DPdata) = 0 ;
      DP_DATA_POINTER(DPdata) = (char *) 0 ;
      DP_MESSAGE_POINTER(DPdata) = DP_EXPOSURE_STATUS(DPdata) - 4 ;
      if (DP_Send(DPdata, DP_SHORT_TIMEOUT(DPdata)))
         return(DP_InquireError(DPdata)) ;
      /*
       * Re-allign the Lines exposed field
       */
      DP_LINES_EXPOSED(DPdata) =
         ((DP_LINES_EXPOSED(DPdata) & 0x007f) << 7) |
         ((DP_LINES_EXPOSED(DPdata) & 0x7f00) >> 8 ) ;
      } /* end inquire status */

   /*
    * Inquire Options.
    */
   if (Sflag & INQ_OPTIONS)
      {
      /*
       * Send the "Inquire Options" command to the Digital Palette.
       * DPsend() will use the "Send Message" command to get the Digital
       * Palette options message.
       * If a problem is encountered try to use the "Inquire Error"
       * command to find out about it and return back to the caller.
       */
      strcpy(DP_COMMAND(DPdata), "IO") ;
      DP_DATA_BYTES(DPdata) = 0 ;
      DP_DATA_POINTER(DPdata) = (char *) 0 ;
      DP_MESSAGE_POINTER(DPdata) = DP_ROM_VERSION(DPdata) - 1 ;
      if (DP_Send(DPdata, DP_SHORT_TIMEOUT(DPdata)))
         return(DP_InquireError(DPdata)) ;
      } /* end inquire options */

   /*
    * Inquire Camera.
    */
   if (Sflag & INQ_CAMERA)
      {
      /*
       * Send the "Inquire Camera" command to the Digital Palette.
       * DPsend() will use the "Send Message" command to get the Digital
       * Palette options message.
       * If a problem is encountered try to use the "Inquire Error"
       * command to find out about it and return back to the caller.
       */
      strcpy(DP_COMMAND(DPdata), "IC") ;
      DP_DATA_BYTES(DPdata) = 0 ;
      DP_DATA_POINTER(DPdata) = (char *) 0 ;
      DP_MESSAGE_POINTER(DPdata) = DP_CAMERADESCRIPTION(DPdata) - 1 ;
      if (DP_Send(DPdata, DP_SHORT_TIMEOUT(DPdata)))
         return(DP_InquireError(DPdata)) ;
      } /* end inquire camera */

   /*
    * Inquire Films
    */
   if (Sflag & INQ_FILMS)
      {
      /*
       * Send the "Inquire Film Name" command to the Digital Palette.
       * DPsend() will use the "Send Message" command to get the
       * Digital Palette Film Name message.
       */
      for (i = 0 ; i < MAX_NUM_FILMS ; i++)
         {
         strcpy(DP_COMMAND(DPdata), "IF") ;
         DP_DATA_BYTES(DPdata) = 1 ;
         DP_DATA_POINTER(DPdata) = (char *) &i ;
         DP_MESSAGE_POINTER(DPdata) = DP_FILM_NAME(DPdata, i) ;
         if (DP_Send(DPdata, DP_SHORT_TIMEOUT(DPdata)))
            DP_InquireError(DPdata) ;
         if (DP_ERRORCLASS(DPdata))
            if ((DP_ERRORCLASS(DPdata) == LOGICERR) &&
               (DP_ERRORNUMBER(DPdata) == 15))
               {
               DP_FILM_NAME(DPdata, i)[0] = '\0' ;
               DP_ERRORCLASS(DPdata) = NOERROR ;
               DP_ERRORNUMBER(DPdata) = 0 ;
               }
            else
               return(DP_ERRORCLASS(DPdata)) ;
         }
      }
      
   /*
    * Inquire Aspect Ratio
    */
   if (Sflag & INQ_ASPECT)
      {
      /*
       * Send the "Inquire Aspect Ratio" command to the Digital
       * Palette.
       * DPsend() will use the "Send Message" command to get the Digital
       * Palette Aspect Ratio message.
       * If a problem is encountered try to use the "Inquire Error"
       * command to find out about it and return back to the caller.
       */
      for (i = 0 ; i < MAX_NUM_FILMS ; i++)
         {
         if (DP_FILM_PRESENT(DPdata, i))
            {
            strcpy(DP_COMMAND(DPdata), "IA") ;
            DP_DATA_BYTES(DPdata) = 1 ;
            DP_DATA_POINTER(DPdata) = (char *) &i ;
            DP_MESSAGE_POINTER(DPdata) = DP_ASPECT_MESSAGE(DPdata, i) ;
            if (DP_Send(DPdata, DP_SHORT_TIMEOUT(DPdata)))
               return(DP_InquireError(DPdata)) ;
            }
         else
            {
            DP_ASPECT_MESSAGE(DPdata, i)[0] = '\0' ;
            DP_ASPECT_MESSAGE(DPdata, i)[1] = '\0' ;
            DP_ASPECT_MESSAGE(DPdata, i)[2] = '\0' ;
            }
         }
      }

   /*
    * Inquire Buffer.
    */
   if (Sflag & INQ_BUFFER)
      {
      /*
       * Send the "Inquire Buffer" command to the Digital Palette.
       * DPsend() will use the "Send Message" command to get the Digital
       * Palette status message.
       * If a problem is encountered try to use the "Inquire Error"
       * command to find out about it and return back to the caller.
       */
      strcpy(DP_COMMAND(DPdata), "IB") ;
      DP_DATA_BYTES(DPdata) = 0 ;
      DP_DATA_POINTER(DPdata) = (char *) 0 ;
      DP_MESSAGE_POINTER(DPdata) = (char *) &(DP_FREE_BUFFER(DPdata)) ;
      if (DP_Send(DPdata, DP_SHORT_TIMEOUT(DPdata)))
         return(DP_InquireError(DPdata)) ;
      /*
       * Re-allign the Buffer fields
       */
      DP_FREE_BUFFER(DPdata) =
         ((DP_FREE_BUFFER(DPdata) & 0x007f) << 7) |
         ((DP_FREE_BUFFER(DPdata) & 0x7f00) >> 8 ) ;
      DP_TOTAL_BUFFER(DPdata) =
         ((DP_TOTAL_BUFFER(DPdata) & 0x007f) << 7) |
         ((DP_TOTAL_BUFFER(DPdata) & 0x7f00) >> 8 ) ;
      } /* end inquire status */

   DP_DPALETTE_ONLINE(DPdata) = 1 ;
   return(DP_ERRORCLASS(DPdata)) ;
   }

/*
 * DP_InquireError
 */
static int
DP_InquireError(DPdata)
   DP_DATA   *DPdata ;
   {
   int           SaveError ;

   if ((DP_ERRORCLASS(DPdata) != CONFIGERR) &&
		(DP_ERRORCLASS(DPdata) != DPTOOLKITERR))
		DP_ERRORNUMBER(DPdata) = 0 ;
	
   /*
    * Handle Digital Palette Errors.
    * The current value of DP_ERRORCLASS(DPdata) may change.
    */
   if ((!DP_ERRORCLASS(DPdata)) || (DP_PRINTERERROR(DPdata)))
      {
      /*
       * Send an Inquire Error command to the Digital Palette.  This will
       * force the Digital Palette to set the error line if there is a latent
       * error waiting for the next five byte command packet.
       * If the error condition, after sending this five byte command packet
       * is LOGICERR or HARDWERR then clear the error and then ask the Digital
       * Palette for an error description that we will use for an error
       * message.
       *
       * Set up parameters for Inquire Error.
       */
      strcpy(DP_COMMAND(DPdata), "IE") ;
      DP_DATA_BYTES(DPdata) = 0 ;
      DP_DATA_POINTER(DPdata) = (char *) 0 ;
      DP_MESSAGE_POINTER(DPdata) = DP_ERRORMESSAGE(DPdata) - 1 ;

      /*
       * If the error line is not set at this point, the next five byte
       * command packet may set it.  Since this code is trying to resolve
       * any error conditions which may exist first force a latent error
       * by sending down a five byte data packet.
       */
		if (!DP_ERRORCLASS(DPdata))
         SaveError = DP_Send(DPdata, DP_SHORT_TIMEOUT(DPdata)) ;
		else
			SaveError = DP_ERRORCLASS(DPdata) ;

      /*
       * Clear any error condition which may now be set.  Don't
       * bother checking for additional errors.
       * Get the Digital Palette error message.
       */
      if (SaveError)
         {
         if (DP_ERRORCLASS(DPdata) = DP_ClearError())
            {
            strcpy(DP_ERRORMESSAGE(DPdata), ErrorNotCleared) ;
            DP_ERRORNUMBER(DPdata) = 31 ;
            if (SaveError)
               DP_ERRORCLASS(DPdata) = SaveError ;
            return(DP_ERRORCLASS(DPdata)) ;
            }
         strcpy(DP_COMMAND(DPdata), "IE") ;
         DP_DATA_BYTES(DPdata) = 0 ;
         DP_DATA_POINTER(DPdata) = (char *) 0 ;
         DP_MESSAGE_POINTER(DPdata) = DP_ERRORMESSAGE(DPdata) - 1 ;
         if (DP_Send(DPdata, DP_SHORT_TIMEOUT(DPdata)))
            {
            strcpy(DP_ERRORMESSAGE(DPdata), ErrorNotFound) ;
            return(DP_ERRORCLASS(DPdata)) ;
            }
         DP_ERRORCLASS(DPdata) = SaveError ;
         }
      DP_ERRORNUMBER(DPdata) = (DP_ERRORNUMBER(DPdata) >> 8) & 0x00ff ;
      }
   
   /*
    * Final check on error class.
    * Set error messages for non Digital Palette errors and warnings.
    * Handle special cases of Digital Palette errors.
    */
   switch(DP_ERRORCLASS(DPdata))
      {
         /*
          * Toolkit interface routines generate warnings as well as errors.
          * In the spirit of error handling we will set an error message that
          * the user can understand and return the warning.
          */
      case BUFFERWARNING:
         strcpy(DP_ERRORMESSAGE(DPdata), NoBufferSpace) ;
         break ;
      case EXPOSUREACTIVE:
         strcpy(DP_ERRORMESSAGE(DPdata), ExposureInBox) ;
         break ;
      case REMOVEFILM:
         strcpy(DP_ERRORMESSAGE(DPdata), ExposureComplete) ;
         break ;
      case NOERROR:
         /*
          * No error condition.  No error existed on entry to this routine.
          * No error was generated while getting the last error message from
          * the Digital Palette.
          */
         strcpy(DP_ERRORMESSAGE(DPdata), NoErrorsReported) ;
         break ;
      case LOGICERR:
         if (DP_ERRORMESSAGE(DPdata)[0] == 0)
            strcpy(DP_ERRORMESSAGE(DPdata), ErrorNotFound) ;
         break ;
      case HARDWERR:
         if (DP_ERRORNUMBER(DPdata) == 1)
            DP_DPALETTE_INITIALIZED(DPdata) = 0 ;
         break ;
      case TIMEOUT:
         /*
          * If a TIMEOUT error exist then there is no point in further
          * attempts at communication with the Digital Palette.  Set an error
          * message that the user can understand and return the error
          * condition.
          */
         DP_DPALETTE_ONLINE(DPdata) = 0 ;
         DP_DPALETTE_INITIALIZED(DPdata) = 0 ;
         strcpy(DP_ERRORMESSAGE(DPdata), Incommunicado) ;
         break ;
      case DISCONNECTED:
         strcpy(DP_ERRORMESSAGE(DPdata), Disconnected) ;
         break ;
      case UNKNOWNPORT:
         strcpy(DP_ERRORMESSAGE(DPdata), UnknownPort) ;
         break ;
      case CONFIGERR:
         if (DP_ERRORNUMBER(DPdata) == CFG_NO_ENVIRONMENT)
            strcpy(DP_ERRORMESSAGE(DPdata), cfgNoEnvironment) ;
         else if (DP_ERRORNUMBER(DPdata) == CFG_FILE_OPEN_ERROR)
            strcpy(DP_ERRORMESSAGE(DPdata), cfgFileOpenError) ;
         else if (DP_ERRORNUMBER(DPdata) == CFG_FILE_READ_ERROR)
            strcpy(DP_ERRORMESSAGE(DPdata), cfgFileReadError) ;
         else if (DP_ERRORNUMBER(DPdata) == CFG_PORT_ERROR)
            strcpy(DP_ERRORMESSAGE(DPdata), UnknownPort) ;
         else if (DP_ERRORNUMBER(DPdata) == CFG_FILM_OPEN_ERROR)
            strcpy(DP_ERRORMESSAGE(DPdata), cfgFilmReadError) ;
         else
            strcpy(DP_ERRORMESSAGE(DPdata), cfgUnknownError) ;
         break ;
      case DPTOOLKITERR:
         if (DP_ERRORNUMBER(DPdata) == TK_BAD_IMG_COMP)
            strcpy(DP_ERRORMESSAGE(DPdata), BadImageCompression) ;
         else if (DP_ERRORNUMBER(DPdata) == TK_BAD_TERM_METHOD)
            strcpy(DP_ERRORMESSAGE(DPdata), BadTermMethod) ;
         else
            strcpy(DP_ERRORMESSAGE(DPdata), BadToolkitUsage) ;
         break ;
      default:
         /*
          * Default error condition.  This error message would indicate
          * incorrect toolkit interface usage or a bug someplace.
          */
         strcpy(DP_ERRORMESSAGE(DPdata), UnknownError) ;
         break ;
      }

   return(DP_ERRORCLASS(DPdata)) ;
   }

/*
 * DP_ConfirmBuffer
 */
int
DP_ConfirmBuffer(DPdata, BytesNeeded, Wait)
   DP_DATA   *DPdata ;
   int        BytesNeeded ;
   int        Wait ;        /* internal Toolkit waitforbuffer */
   {
   int        Kbytes ;

   /*
    * Convert to KiloBytes which is how we'll get the buffer availabilty from
    * the Digital Palette.
    */
	Kbytes = BytesNeeded >> 10 ; /* quick divide by 1024 */
	if (BytesNeeded & 0x3ff)     /* quick modulo 1024 test */
		Kbytes ++ ;

   /*
    *    Make sure that the Digital Palette has Kbytes in available buffer
    * space.  Adjust the BufferFree entry in the data structure.  If this
    * value is above 4K, we'll adjust this value by the amount of data the app
    * wants to send and return with no errors.
    */
   if (Kbytes < DP_FREE_BUFFER(DPdata))
      {
		DP_FREE_BUFFER(DPdata) -= Kbytes ;
		return(DP_ERRORCLASS(DPdata) = 0) ;
		}

	/*
    * If the WaitForBuffer flag is not set then the caller wants to know about
    * the lack of buffer space and we'll return BUFFERWARNING.  Otherwise
    * wait for buffer space to become available.
    */
   do
      {
      if (DP_GetPrinterStatus(DPdata, INQ_BUFFER | INQ_STATUS))
         return(DP_ERRORCLASS(DPdata)) ;
      if (DP_FREE_BUFFER(DPdata) < Kbytes)
         {
         /*
          * If the Toolkit or the application says wait until buffer space
          * becomes available, then we wait a couple of seconds
          */
         if ((Wait) || (DP_WAITFORBUFFER(DPdata)))
            DP_Sleep(2) ;
         else
            {
            DP_ERRORCLASS(DPdata) = BUFFERWARNING ;
            return(DP_ERRORCLASS(DPdata)) ;
            }
         }
      } while (DP_FREE_BUFFER(DPdata) < Kbytes) ;
   return(DP_ERRORCLASS(DPdata)) ;
   }

/*
 * DP_ExposureWarning
 */
int
DP_ExposureWarning(DPdata)
   DP_DATA   *DPdata ;
   {
   /*
    * Ask the Digital Palette is it is currently exposing an image.  If it
    * isn't then this routine doesn't need to generate a warning and Timeout
    * limit should be DP_SHORT_TIMEOUT(DPdata).  Otherwise the Timeout limit
    * should be increased if servo mode is on and then we need to check
    * whether this routine needs to return a warning.
    */
   if (DP_GetPrinterStatus(DPdata, INQ_STATUS))
      return(DP_ERRORCLASS(DPdata)) ;
   if (!DP_EXPOSINGIMAGE(DPdata))
      {
      DP_TIMEOUT(DPdata) = DP_SHORT_TIMEOUT(DPdata) ;
      return(DP_ERRORCLASS(DPdata)) ;
      }

   if (DP_SERVO_MODE(DPdata) && !DP_EXP_BUFFER_USAGE(DPdata))
      DP_TIMEOUT(DPdata) = DP_LONG_TIMEOUT(DPdata) ;
   else
      DP_TIMEOUT(DPdata) = DP_SHORT_TIMEOUT(DPdata) ;

   if (!DP_SINGLEIMAGEMODE(DPdata))
      return(DP_ERRORCLASS(DPdata)) ;

   /*
    * If the WaitForBuffer flag is not set and an exposure is in progress and
    * and the camera is not an auto advance type then we'll return an
    * EXPOSUREACTIVE warning immediately.
    */
   if (!DP_WAITFORBUFFER(DPdata))
      {
      DP_ERRORCLASS(DPdata) = EXPOSUREACTIVE ;
      return(DP_ERRORCLASS(DPdata)) ;
      }
   
   /*
    * Wait 2 seconds and ask the Digital Palette again if it is exposing an
    * an image.  Keep monitoring the progress of the exposure until it is
    * complete.
    */
   while (DP_EXPOSINGIMAGE(DPdata))
      {
      DP_Sleep(2) ;
      if (DP_GetPrinterStatus(DPdata, INQ_STATUS))
         return(DP_ERRORCLASS(DPdata)) ;
      }

   /*
    * Exposure is complete.  Set a warning to remove the film, set a short
    * TimeOut limit and return.
    */
   DP_ERRORCLASS(DPdata) = REMOVEFILM ;   
   DP_TIMEOUT(DPdata) = DP_SHORT_TIMEOUT(DPdata) ;
   return(DP_ERRORCLASS(DPdata)) ;
   }
