/*
	SCSI interface for SGI
*/

#include <stdio.h>
#include <signal.h>
#include <sys/types.h>
#include <fcntl.h>
#include <malloc.h>

#include "dslib.h"
#include <stdarg.h>

#ifdef LSCV3
#include <strings.h>
#else
#include <string.h>
#endif

#include <errno.h>

#include "dpalette.h"
#include "sclowlvl.h"
#include "tkinquir.h"

#define MAX_DEVICES 8

#define NO          0
#define YES         1
#define NONE        0xFFFF

int DP_scsi_driver(char *, int, char *, int, char *, int);
int DP_scsi_adptrst(int);
void DP_scsi_reset();
int DP_host_retrieve_scsi_error(DP_DATA *, int);
int DP_scsi_setup(DP_DATA *, char **);
int DP_scsi_allocate(int);
int DP_scsi_deallocate(int);

typedef struct
{
  unsigned char SCSI_key;
  unsigned char Device_Count;
  int Palette;
} DEV_LOOKUP;

static DEV_LOOKUP SCSI_addr[8];	/* the index will be scsi_id */

static int SCSI_id=1;
static struct dsreq *dsp=NULL;
static int last_dev_count = -1;
static int done_once = NO;

static char GES_CDB[6] = {3,0,0,0,10,0};
static char INQ_CDB[6] = {18,0,0,0,63,0};
static char inq_data[9][INQUIRY_BUFFER_SIZE];
static char *inqdptr;

/*----------------------------------------------------------------------
This routine is the main SCSI driver which performs all SCSI IO.

-----------------------------------------------------------------------*/

int DP_scsi_driver( cdb, scsi_id, data_ptr, data_size, extended_sense, dir )
char *cdb, *data_ptr, *extended_sense;
int data_size, scsi_id, dir;
{
  int st,i;
  int dev_cnt;
  char devfname[20];
  char *local_data_ptr;

#ifdef DEBUG
  printf("scsi_id: %d, command: %d, data_size: %d\n", scsi_id, (int) cdb[0], data_size);
#endif

  if( (((unsigned long)data_ptr) & 3) != 0)
  {
#ifdef DEBUG
    printf("data_ptr not aligned: %8.8x. size: %d\n", (unsigned long) data_ptr, data_size);
#endif
    local_data_ptr = malloc(data_size);
    if(dir != SCSI_READ)
    {
      for(i=0; i<data_size; i++) local_data_ptr[i] = data_ptr[i];
    }
  }
  else
  {
    local_data_ptr = data_ptr;
  }

  if(SCSI_addr[scsi_id].Palette != YES)
  {
#ifdef DEBUG
    printf("DP_scsi_driver return 1\n");
#endif
    return(0x0f);
  }

  dev_cnt = SCSI_addr[scsi_id].Device_Count;

  if(dev_cnt != last_dev_count)
  {
    if(last_dev_count != -1)
    {
      dsclose(dsp);
      dsp = NULL;
    }
    sprintf(devfname, "/dev/scsi/sc0d%dl0", dev_cnt);
    dsp = dsopen(devfname, O_RDWR);
    last_dev_count = dev_cnt;
    if(dsp == NULL)
    {
#ifdef DEBUG
      printf("DP_scsi_driver return 2\n");
#endif
      return;
    }
  }

  /*
	Insert the SCSI command.
  */

  CMDLEN(dsp) = 6;
  for(i=0; i<6; i++) CMDBUF(dsp)[i] = cdb[i];

  /*
	Execute the command:
  */

  if(dir == SCSI_READ)
  {
    filldsreq(dsp, local_data_ptr, data_size, DSRQ_READ);
  }
  else
  {
    filldsreq(dsp, local_data_ptr, data_size, DSRQ_WRITE);
  }
  st = doscsireq(getfd(dsp), dsp);
  if(data_ptr != local_data_ptr)
  {
    if(dir == SCSI_READ)
    {
      for(i=0; i<data_size; i++) data_ptr[i] = local_data_ptr[i];
    }
    free(local_data_ptr);
  }
  if(st == 0)
  {
#ifdef DEBUG
    printf("doscsireq OK.\n");
#endif
    return(SCSI_COMMAND_OK);
  }
  else
  {
    /*
	Get extended sense:
    */
#ifdef DEBUG
    printf("doscsireq BAD. st = %d\n", st);
#endif
    if(st == 255)
    {
      return (-1);
    }
    /* abort(); */
    st = requestsense03(dsp, extended_sense, SENSE_SIZE, 0);
    if(st == 0)
    {
#ifdef DEBUG
      printf("Got extended sense: ");
      for(i=0; i<10; i++)
      printf("%2.2x ", extended_sense[i]);
      printf("\n");
#endif
      return(EXTSENSE_VALID);
    }
  }
  return(st);
} /* end DP_scsi_driver() */

/*------------------------------------------------------------------------
   issue a reset pulse on the scsi bus. This function is not called by any
   of the toolkit routines.  It is only included here for completeness in
   case it's needed in the future.
-------------------------------------------------------------------------*/

int DP_scsi_adptrst(dev_cnt)
    int dev_cnt;
{
}

/*-----------------------------------------------------------------------
Issue a global reset to the adapter and all SCSI attached devices:
------------------------------------------------------------------------*/

void DP_scsi_reset()
{
  return;
}

/*------------------------------------------------------------------------
int DP_host_retrieve_scsi_error( dp, error )

    fills in the error class, number, and message entries in the DP_DATA
    structure for errors which are generated by the host side scsi driver.
        
    entry:
            DP_DATA  *dp      pointer to a structure of type DP_DATA
            int error         Error which was returned by DP_scsi_driver()

    exit:
            The class of the error
---------------------------------------------------------------------------*/

int DP_host_retrieve_scsi_error( dp, error )
DP_DATA     *dp ;
int error ;
{
  DP_ERRORNUMBER(dp) = errno;
#ifdef DEBUG
  printf("\nDP_host_retrieve_scsi_error: %d %d %s\n", error, errno, strerror(errno));
#endif
  strcpy(DP_ERRORMESSAGE(dp), strerror(errno));
  DP_ERRORCLASS(dp) = 87;
  return( DP_ERRORCLASS( dp )) ;
}

/*--------------------------------------------------------------------------
DP_scsi_setup( DP_DATA *dp, char *driver_name )

    DP_scsi_setup is called once for each SCSI device by the DP_InitPrinter 
	function.  It can be used to plug in DMA or interrupt routines which 
	may be needed by the host side SCSI driver.  Keep in mind that an 
	application may call the InitPrinter function multiple times so that 
	if this function installs stuff which should only occur once, it should 
	lock out the installation on subsequent calls.
        
    The function should set the driver name and do an init.  If the init
    fails, the error class, error number, and an error message should be
    set into the DP_DATA structure.  The error entries in the DP_DATA
    structure do not need to be touched if no errors occur.
        
    entry:
        DP_DATA  *dp      pointer to a structure of type DP_DATA
            
        char *driver_name pointer to a character string.  The pointer must 
                          be set here to a string which will be strcat'd to
                          the Palette Toolkit Version name. This way, the
                          app can get information about the SCSI driver which
                          is embedded in the Toolkit.
                          ** THIS STRING SHOULD NOT EXCEED 15 CHARS **
            
    exit:
        error class       0 if all went well.  The error class otherwise
----------------------------------------------------------------------------*/
            
#define HOST_SCSI_NAME  "SGI SCSI"

int DP_scsi_setup( dp, driver_name )
DP_DATA *dp ;
char **driver_name ;

{
  char devfname[20];
  int dev_count;
  int st;

  *driver_name = HOST_SCSI_NAME;

  if(done_once == NO)
  {
    done_once = YES;
    for(dev_count = 0; dev_count<8; dev_count++) SCSI_addr[dev_count].Palette = NO;

    for(dev_count = 1; dev_count<8; dev_count++)
    {
#ifdef DEBUG
      printf("Checking SCSI device %d\n", dev_count);
#endif
      sprintf(devfname, "/dev/scsi/sc0d%dl0", dev_count);
      if(dsp != NULL)
      {
	dsclose(dsp);
	dsp = NULL;
      }
      dsp = dsopen(devfname, O_RDWR);
      if(dsp == NULL)
      {
#ifdef DEBUG
	printf(" - could not open file.\n");
#endif
	continue;
      }

      inqdptr = &inq_data[dev_count][0];
      st = inquiry12(dsp, inqdptr, INQUIRY_BUFFER_SIZE, 0);
      if(st != 0)
      {
#ifdef DEBUG
	printf(" - could not perform inquiry. st = %d\n", st);
#endif
	dsclose(dsp);
	dsp = NULL;
	continue;
      }

      /* Compare the strings: */

      if(!strcmp(&inqdptr[INQ_IDENTIFICATION], IDENT_STRING))
      {
	SCSI_addr[SCSI_id].Device_Count = dev_count;
	SCSI_addr[SCSI_id].Palette = YES;
	SCSI_id++;
#ifdef DEBUG
	printf("OK - This is a Digital Palette.\n");
#endif
      }
      else
      {
#ifdef DEBUG
	printf(" - id mismatch: %s %s\n", &inqdptr[INQ_IDENTIFICATION], IDENT_STRING);
#endif
      }
      dsclose(dsp);
      dsp = NULL;
    } /* dev_count loop */
  } /* done_once check */

#ifdef DEBUG
  printf("DP_scsi_setup: SCSI_id: %d\n", SCSI_id);
#endif
  return(NOERROR);
} /* end of DP_scsi_setup */

